Pro implementaci klientské aplikace jsem se rozhodl použít porgramovací jazyk Typescript, jak jsem již odůvodnil v podkapitole 6.1. Oproti Javascript (který bude výstupem) má tu výhodu, že umožňuje psát staticky typovaný kód, což využiji zejména k našeptávání v IDE. 

\subsection*{Vlastní komponenty}
Aplikace využívá možnosti definování vlastních komponent (tzv. custom components). Za tímto účelem jsem vytvořil třídu AbstractComponent. Tato třída není určená k inicializaci objektů, ale k vytváření nových tříd zděděním této třídy. Každá třída, která z ní dědí musí přepsat vlastnost tagName, která definuje název značky, pod jakým se komponenta bude zobrazovat v html dokumentu. Je zde pravidlem, že se v názvu musí vyskytovat alespoň jedna pomlčka.
Kromě této vlastnosti existuje několik metod, které je možné v potomcích implementovat:
\begin{itemize}
    \item addListeners()
    \item connectedCallback()
    \item disconnectedCallback()
    \item attributeChangedCallback()
    \item disconnectComponent()
\end{itemize}

Ve skutečnosti opomenutá implementace některé z těchto metod aktuálně vede k vyvolání vyjímky, ale toto chování je možné vypnout v třídě Config.

Dále se ve funkci nachází několik funkci pro přidávání jiných komponent k dané komponentě a metoda initializeFromProps(), která se volá z konstruktoru pro nastavení komponenty (a případně je možné ji kdykoliv volat znovu odjinud - v případě že se nějak změní žádané vlastnosti a chceme komponentu reinicializovat). Zmíněná metoda přijímá jako parametr rozhraní IComponentProperties, které obsahuje několik vlastností, kterými je možné komponentu nastavit (např. komponenty, které se připojí jako dceřinné prvky v HTML dokumentu) a dále všechny CSS vlastnosti (je tak možné již při vytváření komponenty nadefinovat její výchozí vzhled). Samozřejmě CSS vlastnosti jsou uloženy v patřičném CSS souboru, ale díky rozhraní IComponentProperties je možné udržet CSS kód bez zbytečných detailů a mlže tak obsahovat pouze obecné styly. ??V dalším textu používám frázi komponenta a instance třídy (dědící z AbstractComponent) jako synonymum??.

\subsection*{Životní cyklus aplikace ???}
Vstupní třída aplikace je AutoHomeApp. Zde se nainicializují Firebase funkce, nadefinují všechny vlastní komponenty a nakonec se vytvoří instance třídy PageCreator. Ta je, jak vyplývá z jejího názvu zodpovědná za celkové sestavení HTML dokumentu. Ústřední metoda této funkce se nazývá renderPage(). V konstruktoru třídy PageCreator se zmíněná metoda zaregistruje v instanci třídy URLManager, na kterou se vždy posílá požadavek na změnu stránky (zejm. při kliknutí na položku menu) a ta vždy následně volá zaregistrovanou metodu renderPage().

V renderPage() se získá (z instance třídy AppRouter) informace, která stránka se má aktuálně vytvořit. Není-li definovaná, tak se pošle požadavek (instanci třídy URLManager) na přesměrování na domovskou stránku. V opačném případě se vytvoří a přidá do správce stránek (instance třídy PageManager) požadovaná stránka (pokud se tam již nenachází) a následně se aktivuje. 

Stránky, které se přidávají do správce stránek jsou vlastní komponenty, které dědí třídu BasePage. Jejich vlastností je, že jsou pozicovány absolutně a jejich šířka je rovna šířce okna prohlížeče. Veškerá logika, která není implementovaná přímo v jednotlivých komponentách je řešena právě v jednotlivých potomcích třídy BasePage.

Celkem se v aplikaci vyskytují 3 stránky:
\begin{itemize}
    \item Přihlaškovací
    \item Stránka s registrací nového uživatele
    \item Domovská stránka
    \item Nastavení
\end{itemize}

\subsection*{implementace jednotlivých stránek}
Na stránkách s přihlášením a registrací není vcelku nic zajímavého, nachází se tam jen formulář pro přihlášení, resp. registraci. 
Domovská stránka (komponenta HomePage) je sestavena z komponent RoomCard (karet místností). V konstruktoru domovské stránky se registruje posluchač události změny databáze (konkrétně změny v místnostech). Při vyvolání této události se vyhodnotí, zda se změnilo pořadí místností (v tomto případě se znovu sestaví celé rozložení domovské stránky). Dále se (nezávisle na změně pořadí místností) aktualizují jednotlivé karty místností voláním metody updateCard() na těchto komponentách. 

Nastavení (komponenta SettingsPage) se skládá z několika komponent ListFrame (editovatelný seznam), TabLayout (rozložení se záložkami) a jednoho DetailFrame (editovatelného detailu). Z TabLayout komponent je vytvořena hierarchie seznamů pro výběr položky k editaci. V aplikaci je TabLayout pro místnosti, moduly a pak společný pro snímače a zařízení. Z praktického hlediska má využití jen pro dvojici snímače a zařízení, ale použil jsem ho i pro místnosti a moduly, protože snadno (jako název záložky) zobrazuje o co v dané úrovni jde.
Detail slouží pro editaci posledně zvolené položky v některém ze seznamu.